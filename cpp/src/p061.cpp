//
// Created by Haralambi Todorov on 09/07/2017.
//

/// Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal)
/// numbers and are generated by the following formulae:
/// Triangle	 	P3,n=n(n+1)/2	 	1, 3, 6,  10, 15, ...
/// Square	 	    P4,n=n2	 	        1, 4, 9,  16, 25, ...
/// Pentagonal	 	P5,n=n(3n−1)/2	 	1, 5, 12, 22, 35, ...
/// Hexagonal	 	P6,n=n(2n−1)	 	1, 6, 15, 28, 45, ...
/// Heptagonal	 	P7,n=n(5n−3)/2	 	1, 7, 18, 34, 55, ...
/// Octagonal	 	P8,n=n(3n−2)	 	1, 8, 21, 40, 65, ...
/// The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
///
/// 1. The set is cyclic, in that the last two digits of each number is the first two digits of the next number
/// (including the last number with the first).
///
/// 2. Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is represented
/// by a different number in the set.
///
/// 3. This is the only set of 4-digit numbers with this property.
///
/// Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle,
/// square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.

#include <assert.h>
#include <iostream>
#include <set>
#include <vector>

inline uint32_t triangle(const uint32_t &n) {
    return n * (n + 1) / 2;
}

inline uint32_t square(const uint32_t &n) {
    return n * n;
}

inline uint32_t pentagon(const uint32_t &n) {
    return n * (3 * n - 1) / 2;
}

inline uint32_t hexagon(const uint32_t &n) {
    return n * (2 * n - 1);
}

inline uint32_t heptagon(const uint32_t &n) {
    return n * (5 * n - 3) / 2;
}

inline uint32_t octagon(const uint32_t &n) {
    return n * (3 * n - 2);
}

std::vector<uint32_t> generate_pairs(int type) {
    uint32_t ni{1}, n{0};
    std::vector<uint32_t> r;

    while (n < 10000) {
        switch (type) {
            case 0:
                // triangle number
                n = triangle(ni);
                break;
            case 1:
                // square number
                n = square(ni);
                break;
            case 2:
                // pentagon number
                n = pentagon(ni);
                break;
            case 3:
                // hexagon number
                n = hexagon(ni);
                break;
            case 4:
                // heptagon number
                n = heptagon(ni);
                break;
            case 5:
                // octagon number
                n = octagon(ni);
                break;
        }
        if (n > 999 && n < 10000)
            r.push_back(n);
        ni++;
    }
    return r;
}

bool c(const uint32_t &a, const uint32_t &b) {
    return (a / 100) == (b % 100);
}

int main() {
    // test triangle number generation
    assert(1 == triangle(1));
    assert(3 == triangle(2));
    assert(6 == triangle(3));
    assert(10 == triangle(4));
    assert(15 == triangle(5));

    // test square number generation
    assert(1 == square(1));
    assert(4 == square(2));
    assert(9 == square(3));
    assert(16 == square(4));
    assert(25 == square(5));

    // test pentagonal number generation
    assert(1 == pentagon(1));
    assert(5 == pentagon(2));
    assert(12 == pentagon(3));
    assert(22 == pentagon(4));
    assert(35 == pentagon(5));

    // test hexagonal number generation
    assert(1 == hexagon(1));
    assert(6 == hexagon(2));
    assert(15 == hexagon(3));
    assert(28 == hexagon(4));
    assert(45 == hexagon(5));

    // test heptagonal number generation
    assert(1 == heptagon(1));
    assert(7 == heptagon(2));
    assert(18 == heptagon(3));
    assert(34 == heptagon(4));
    assert(55 == heptagon(5));

    // test octagonal number generation
    assert(1 == octagon(1));
    assert(8 == octagon(2));
    assert(21 == octagon(3));
    assert(40 == octagon(4));
    assert(65 == octagon(5));

    // test getting 2 leading digits of a number
    assert(c(8128, 8281));
    assert(c(2882, 8128));

    // vector to contain pairs of parameter and its corresponding triangle number, which is in range [1000, 9999]
    std::vector<uint32_t> triangles = generate_pairs(0);
    std::vector<uint32_t> squares   = generate_pairs(1);
    std::vector<uint32_t> pentagons = generate_pairs(2);
    std::vector<uint32_t> hexagons  = generate_pairs(3);
    std::vector<uint32_t> heptagons = generate_pairs(4);
    std::vector<uint32_t> octagons  = generate_pairs(5);

    // iterate through the last item of the vector to the first and thereby try to find the searched chain
    for (std::vector<uint32_t>::iterator ti = triangles.begin(); ti != triangles.end(); ti++) {

        // find square number, which fulfils the chain rule
        for (std::vector<uint32_t>::iterator si = squares.begin(); si != squares.end(); si++) {

            if (!c(*ti, *si)) continue;

            // find pentagon number, which fulfils the chain rule
            for (std::vector<uint32_t>::iterator pi = pentagons.begin(); pi != pentagons.end(); pi++) {

                if (!c(*si, *pi)) continue;

                // find hexagon number, which fulfils the chain rule
                for (std::vector<uint32_t>::iterator hexi = hexagons.begin(); hexi != hexagons.end(); hexi++) {

                    if (!c(*pi, *hexi)) continue;

                    // find heptagon number, which fulfils the chain rule
                    for (std::vector<uint32_t>::iterator hepi = heptagons.begin();
                         hepi != heptagons.end(); hepi++) {

                        if (!c(*hexi, *hepi)) continue;

                        // find octagon number, which fulfils chain rule
                        for (std::vector<uint32_t>::iterator octi = octagons.begin();
                             octi != octagons.end(); octi++) {

                            if (!c(*hepi, *octi)) continue;

                            std::cout << *ti << ", " << *si << ", " << *pi << ", " << *hexi << ", " << *hepi << ", " << *octi << std::endl;
                        }
                    }
                }
            }
        }
    }
}
